---
title: "Exploratory Data Analysis"
output: html_notebook
---

Log:
* 27/08/2025: Document set-up
* 29/08/2025: Clean data, Data checks added. Basic analysis on distribution of temperatures added.
* 31/08/2025: Updated data cleaning, added aggregation of temperatures by day. Comparison of forecast and total demand (30 min intervals).
* 2/09/2025: Added summary of extreme temperature days and export of daily temperature data.
* 4/09/2025: Fixed inconsistent variable names, added export of combined temperature and demand data at 30-min and daily intervals.

# Set up
```{r}
require(readr)
require(here)
require(tidyverse)
```

# Load in raw data
The `forecastdemand_nsw.csv.zip.partaa` and `forecastdemand_nsw.csv.zip.partab` files were manually extracted using `7-Zip` then re-zipped into the `forecastdemand_nsw.csv.zip` file.

```{r}
in_temp <- readr::read_csv(here::here("data/NSW", 
                                      "temperature_nsw.csv.zip"))
in_totaldemand <- readr::read_csv(here::here("data/NSW", 
                                             "totaldemand_nsw.csv.zip"))
in_forecastdemand <- readr::read_csv(here::here("data/NSW",
                                                "forecastdemand_nsw.csv.zip"))
```

# Data check

Check to see the number of rows in the datasets.

```{r}
nrow(in_totaldemand)
nrow(in_forecastdemand)
nrow(in_temp)
```

There are no NA values in any of the columns in the datasets.

```{r}
colSums(is.na(in_totaldemand))
colSums(is.na(in_forecastdemand))
colSums(is.na(in_temp))
```

Produce basic summaries of the columns in the datasets. 

```{r}
summary(in_totaldemand)
summary(in_forecastdemand)
summary(in_temp)
```


As there is only a single region/location included in each dataset, this can be ignored for the purposes of analysis.

```{r}
table(in_totaldemand$REGIONID)
table(in_forecastdemand$REGIONID)
table(in_temp$LOCATION)
```


# Clean data

Clean and extract date and time data of interest. Timezone has been set as UTC to avoid issues with daylight savings time.

```{r}
# clean total demand data
totaldemand <- in_totaldemand %>%
  dplyr::mutate(
    # convert datetime string into POSIX format
    datetime_posixct = as.POSIXct(DATETIME, 
                                  format="%d/%m/%Y %H:%M", tz="UTC"),
    datetime_posixct = format(datetime_posixct, "%Y-%m-%d %H:%M"),
    datetime_posixct = as.POSIXct(datetime_posixct, format="%Y-%m-%d %H:%M", tz="UTC"),
    datetime_posixlt = as.POSIXlt(datetime_posixct, 
                                  format="%Y-%m-%d %H:%M", tz="UTC"),
    # separate out the components of potential interest
    full_date = as.Date(datetime_posixlt),
    year = 1900 + datetime_posixlt$year, # add 1900 to get calendar year
    month = 1 + datetime_posixlt$mon, # starts at 0, add 1 to get calendar month
    day = datetime_posixlt$mday,
    hour = datetime_posixlt$hour,
    mins = datetime_posixlt$min,
    day_of_week = datetime_posixlt$wday,
    # as all the times are in half-hour intervals, no further cleaning required
    rounded_datetime = datetime_posixct
    ) %>%
  dplyr::select(-datetime_posixct, -datetime_posixlt)

# round datetime values to the nearest half hour to match other datasets
temp_datetimes_rounded <- strptime(in_temp$DATETIME, 
                                   format="%d/%m/%Y %H:%M", tz="UTC")
temp_datetimes_rounded$min <- round(temp_datetimes_rounded$min/30) * 30
# clean temperature data
temp <- in_temp %>%
  dplyr::mutate(
    # convert datetime string into POSIX format
    datetime_posixct = as.POSIXct(DATETIME, 
                                  format="%d/%m/%Y %H:%M", tz="UTC"),
    datetime_posixct = format(datetime_posixct, "%Y-%m-%d %H:%M"),
    datetime_posixlt = as.POSIXlt(datetime_posixct, 
                                  format="%Y-%m-%d %H:%M", tz="UTC"),
    # separate out the components of potential interest
    year = 1900 + datetime_posixlt$year, # add 1900 to get calendar year
    month = 1 + datetime_posixlt$mon, # starts at 0, add 1 to get calendar month
    day = datetime_posixlt$mday,
    hour = datetime_posixlt$hour,
    mins = datetime_posixlt$min,
    day_of_week = datetime_posixlt$wday,
    # time rounded to nearest half hour
    rounded_datetime = as.POSIXct(temp_datetimes_rounded,
                                  format="%Y-%m-%d %H:%M", tz="UTC"),
    full_date = as.Date(rounded_datetime)
  ) %>%
  dplyr::select(-datetime_posixct, -datetime_posixlt)
rm(temp_datetimes_rounded) # no longer needed

# clean forecast demand data
forecastdemand <- in_forecastdemand %>%
  dplyr::mutate(
    # convert datetime string of observation into POSIX format
    datetime_posixct = as.POSIXct(DATETIME, format="%Y-%m-%d %H:%M:%S", tz="UTC"),
    datetime_posixlt = as.POSIXlt(datetime_posixct),
    # separate out the components of potential interest
    full_date = as.Date(datetime_posixct),
    year = 1900 + datetime_posixlt$year, # add 1900 to get calendar year
    month = 1 + datetime_posixlt$mon, # starts at 0, add 1 to get calendar month
    day = datetime_posixlt$mday,
    hour = datetime_posixlt$hour,
    mins = datetime_posixlt$min,
    day_of_week = datetime_posixlt$wday,
    # as all the times are in half-hour intervals, no further cleaning required
    rounded_datetime = datetime_posixct,
    # convert datetime string of update time into POSIX format
    update_posixct = as.POSIXct(LASTCHANGED, format="%Y-%m-%d %H:%M:%S")
    ) %>%
  dplyr::select(-datetime_posixct, -datetime_posixlt)
```

# Data check

Check if there are NAs in the cleaned data.

```{r}
colSums(is.na(totaldemand))
colSums(is.na(forecastdemand))
colSums(is.na(temp))
```

Produce basic summaries of the datasets.

```{r}
summary(totaldemand)
summary(forecastdemand)
summary(temp)
```

The cleaned data appears to be all complete with no missing values.

## Daily temperature

Create a dataset that summarises temperature for each day (minimum, maximum, number of observations within certain ranges). 

```{r}
temp_day <- temp %>%
  # summarise the temperature over the day
  dplyr::summarise(
    # number of observations made for the day
    n_obv = n(),
    # find the min and max temperatures and time which it was recorded
    min_temp = min(TEMPERATURE),
    min_temp_time = DATETIME[which.min(TEMPERATURE)],
    max_temp = max(TEMPERATURE),
    max_temp_time = DATETIME[which.max(TEMPERATURE)],
    # aggregate at the day level
    .by = full_date
  )
```
```{r}
# write daily min/max temperatures to csv
write.csv(temp_day,
          file = here::here("data/NSW/processed", "daily_min_max.csv"),
          row.names = FALSE)
```

# Distribution of temperature

## All temperatures recorded

```{r}
ggplot(temp, aes(x=month, y=TEMPERATURE, group=month)) +
  geom_boxplot() +
  scale_x_discrete(limits=month.abb[1:12]) +
  labs(x="Month", y="Temperature (Celsius)")
```

## Chart, density of daily min & max temps

```{r}
cols <- c("Min" = "blue", "Max"="red")
ggplot(temp_day) +
  geom_density(aes(x=min_temp, col="Min")) +
  geom_density(aes(x=max_temp, col="Max")) +
  labs(x="Temperature (Celsius)", 
       title="Distribution of min and max daily temperatures")
```

## Maximum temperatures per day

```{r}
ggplot(temp_day, aes(x=month(full_date), y=max_temp, group=month(full_date))) +
  geom_boxplot() +
  scale_x_discrete(limits=month.abb[1:12]) +
  labs(x="Month", y="Temperature (Celsius)", 
       title="Maximum temperature per day")
```

Get counts of daily maximum temperatures by 1 degree intervals.

```{r}
g = 1 # grouping size
# calculate frequency within each group
max_hist <- hist(temp_day$max_temp, 
                 # breakpoints
                 seq(floor(min(temp_day$max_temp)/g)*g, # rounding down min
                     ceiling(max(temp_day$max_temp)/g)*g, # rounding up max
                     g),
                 plot=F)
n_cat <- length(max_hist$counts) # number of groups
max_temp_summary <- data.frame(
  from = max_hist$breaks[1:n_cat],
  to = max_hist$breaks[2:(1+n_cat)],
  freq = max_hist$counts
)
# clean up variables
rm(n_cat)
rm(max_hist)
# show summary
max_temp_summary
```


## Minimum temperatures per day

```{r}
ggplot(temp_day, aes(x=month(full_date), y=min_temp, group=month(full_date))) +
  geom_boxplot() +
  scale_x_discrete(limits=month.abb[1:12]) +
  labs(x="Month", y="Temperature (Celsius)", 
       title="Minimum temperature per day")
```

Get counts of daily minimum temperatures by 1 degree intervals.

```{r}
g = 1 # grouping size
# calculate frequency within each group
min_hist <- hist(temp_day$min_temp, 
                 seq(floor(min(temp_day$min_temp)/g)*g, # rounding down min
                     ceiling(max(temp_day$min_temp)/g)*g, # rounding up max
                     g),
                 plot=F)
n_cat <- length(min_hist$counts) # number of groups
min_temp_summary <- data.frame(
  from = min_hist$breaks[1:n_cat],
  to = min_hist$breaks[2:(1+n_cat)],
  freq = min_hist$counts
)
# clean up variables
rm(n_cat)
rm(min_hist)
# show summary
min_temp_summary
```

# Extreme temperature analysis

First set the minimum and maximum temperatures considered as 'extreme' for the purposes of analysis.

```{r}
TEMP_LOW = 5
TEMP_HIGH = 35
```

## Summary of days with extreme temperature events

```{r}
#adding the table of extreme days
extreme_days <- temp %>%
  mutate(extreme = case_when(
    TEMPERATURE < TEMP_LOW ~ "Cold",
    TEMPERATURE > TEMP_HIGH ~ "Hot",
    TRUE ~ "Normal"
  )) %>%
  group_by(full_date) %>%
  summarise(
    min_temp = min(TEMPERATURE, na.rm = TRUE),
    max_temp = max(TEMPERATURE, na.rm = TRUE),
    extreme_flag = any(TEMPERATURE < TEMP_LOW | TEMPERATURE > TEMP_HIGH),
    extreme_type = case_when(
      min_temp < TEMP_LOW ~ "Cold",
      max_temp > TEMP_HIGH ~ "Hot",
      TRUE ~ "Normal"
    )
  )
# frequency by different temperature conditions
table(extreme_days$extreme_type)
round(table(extreme_days$extreme_type)/nrow(extreme_days), 4)

# create table for only the extreme
extreme_days <- extreme_days %>% filter(extreme_flag)
n_extreme_days <- nrow(extreme_days)
```
```{r}
# write extreme days summary to csv
write.csv(extreme_days,
          file = here::here("data/NSW/processed", "extreme_days_summary.csv"),
          row.names = FALSE)
```


## Extended summary of daily temperature information

```{r}
# keep only a single temperature observation for every 30-min interval
# use the most extreme temp if above/below the low/high bounds
# otherwise just use the last value
temp30 <- temp %>%
  dplyr::arrange(DATETIME) %>%
  dplyr::summarise(min_temp = min(TEMPERATURE),
                   max_temp = max(TEMPERATURE),
                   latest_temp = last(TEMPERATURE),
                   .by = c(rounded_datetime)) %>%
  dplyr::mutate(TEMPERATURE = case_when(min_temp<TEMP_LOW ~ min_temp,
                                        max_temp>TEMP_HIGH ~ max_temp,
                                        TRUE ~ latest_temp),
                full_date = date(rounded_datetime))
```

```{r}
temp_day_extended <- temp30 %>%
  # calculate number of consecutive instances of high / low temperature
  dplyr::mutate(is_low = TEMPERATURE<TEMP_LOW,
                is_high = TEMPERATURE>TEMP_HIGH) %>%
  dplyr::group_by(is_low,
                  grp=with(rle(is_low), rep(seq_along(lengths), lengths))) %>%
  dplyr::mutate(low_counter = seq_along(grp)*is_low) %>%
  dplyr::ungroup() %>%
  dplyr::group_by(is_high,
                  grp=with(rle(is_high), rep(seq_along(lengths), lengths))) %>%
  dplyr::mutate(high_counter = seq_along(grp)*is_high) %>%
  dplyr::ungroup() %>%
  # summarise the temperature over the day
  dplyr::summarise(
    # number of observations made for the day
    n_obv = n(),
    # find the min and max temperatures and time which it was recorded
    min_temp = min(TEMPERATURE),
    min_temp_time = rounded_datetime[which.min(TEMPERATURE)],
    max_temp = max(TEMPERATURE),
    max_temp_time = rounded_datetime[which.max(TEMPERATURE)],
    # flag whether there are any extreme temperature observations
    extreme_flag = any(TEMPERATURE < TEMP_LOW | TEMPERATURE > TEMP_HIGH),
    extreme_type = case_when(
      min_temp < TEMP_LOW ~ "Cold",
      max_temp > TEMP_HIGH ~ "Hot",
      TRUE ~ "Normal"),
    # number of intervals in the day outside the extreme bounds
    n_low = sum(TEMPERATURE<TEMP_LOW), 
    n_high = sum(TEMPERATURE>TEMP_HIGH),
    # maximum number of consecutive high/low observations
    # including carry-over from previous day
    n_low_run = max(low_counter),
    n_high_run = max(high_counter),
    # earliest and latest times when the extremes were recorded
    first_low_time = first(rounded_datetime[TEMPERATURE<TEMP_LOW]),
    last_low_time = last(rounded_datetime[TEMPERATURE<TEMP_LOW]),
    first_high_time = first(rounded_datetime[TEMPERATURE>TEMP_HIGH]),
    last_high_time = last(rounded_datetime[TEMPERATURE>TEMP_HIGH]),
    # aggregate at the day level
    .by = full_date
  )
```
```{r}
write.csv(temp_day_extended,
          file = here::here("data/NSW/processed", "daily_extended.csv"),
          row.names = FALSE)
```


## Boxplots of min/max temperatures

Visualise when max temperatures are likely to fall outside of the bounds.

```{r}
ggplot(temp_day_extended, 
       aes(x=month(full_date), y=max_temp, group=month(full_date))) +
  geom_boxplot() +
  geom_hline(yintercept=c(TEMP_LOW, TEMP_HIGH), col="red") +
  scale_x_discrete(limits=month.abb[1:12]) +
  labs(x="Month", y="Max daily temperature (Celsius)")
```

Visualise when min temperatures are likely to fall outside of the bounds.

```{r}
ggplot(temp_day_extended, 
       aes(x=month(full_date), y=min_temp, group=month(full_date))) +
  geom_boxplot() +
  geom_hline(yintercept=c(TEMP_LOW, TEMP_HIGH), col="red") +
  scale_x_discrete(limits=month.abb[1:12]) +
  labs(x="Month", y="Min daily temperature (Celsius)")
```

## Counts of days above/below bounds

Check how many observations fall outside of the extreme temperature bounds; should still be the same as `extreme_days`.

```{r}
temp_day_extended %>%
  dplyr::mutate(year = year(full_date)) %>%
  dplyr::summarise(
    n_min_below_low = sum(min_temp<TEMP_LOW),
    n_max_above_high = sum(max_temp>TEMP_HIGH)
  )
```

Split observations by year to see if there are particular years with higher number of low temperature and/or high temperature days.

```{r}
temp_day_extended %>%
  dplyr::mutate(year = year(full_date)) %>%
  dplyr::summarise(
    n_min_below_low = sum(min_temp<TEMP_LOW),
    n_max_above_high = sum(max_temp>TEMP_HIGH),
    .by = year
  )
```

# Accuracy of current forecast demand (30 min intervals)

## Create joint dataset for analysis

```{r}
combined_dataset <- forecastdemand %>%
  # take only the last prediction
  dplyr::slice_max(LASTCHANGED, by=rounded_datetime) %>%
  dplyr::select(FORECASTDEMAND, rounded_datetime) %>%
  dplyr::inner_join(
    totaldemand %>% dplyr::select(TOTALDEMAND, rounded_datetime),
    by = join_by(rounded_datetime)) %>%
  dplyr::inner_join(
    temp30 %>%
      dplyr::select(TEMPERATURE, rounded_datetime),
    by = join_by(rounded_datetime)) %>%
  dplyr::mutate(
    error = TOTALDEMAND-FORECASTDEMAND,
    extreme_flag = any(TEMPERATURE < TEMP_LOW | TEMPERATURE > TEMP_HIGH),
    extreme_type = case_when(
      TEMPERATURE < TEMP_LOW ~ "Cold",
      TEMPERATURE > TEMP_HIGH ~ "Hot",
      TRUE ~ "Normal"),
    extreme_type = factor(extreme_type, c("Cold", "Normal", "Hot")),
    year = format(rounded_datetime, "%Y")) %>%
  dplyr::rename(DATETIME = rounded_datetime) %>%
  dplyr::select(DATETIME, TEMPERATURE, TOTALDEMAND, FORECASTDEMAND,
                error, extreme_flag, extreme_type, year)
```
```{r}
write.csv(combined_dataset,
          file = here::here("data/NSW/processed", "nsw_30mins.csv"),
          row.names = FALSE)
```


## Chart, forecast vs actual demand by temperature

```{r}
mid_temp <- sum(c(TEMP_LOW, TEMP_HIGH)) / 2
ggplot(combined_dataset, 
       aes(FORECASTDEMAND, TOTALDEMAND, col=TEMPERATURE, alpha=TEMPERATURE)) + 
  geom_point() +
  scale_color_gradient2(
    low="blue", mid="lightyellow", high="red",
    midpoint=mid_temp,
    breaks=c(TEMP_LOW, mid_temp, TEMP_HIGH))
```

```{r}
ggplot(combined_dataset, 
       aes(FORECASTDEMAND, TOTALDEMAND, col=TEMPERATURE)) + 
  geom_point() +
  scale_color_gradient2(
    low="blue", mid="lightyellow", high="red",
    midpoint=mid_temp,
    breaks=c(TEMP_LOW, mid_temp, TEMP_HIGH)) +
  facet_wrap(~extreme_type)
```

## Chart, error in forecast by temperature

```{r}
ggplot(combined_dataset, 
       aes(TEMPERATURE, error)) + 
  geom_point()
```

```{r}
ggplot(
  data = combined_dataset %>%
    dplyr::mutate(
      # group temperatures into lots of 5
      temp_cut = cut(TEMPERATURE, 
                      breaks=seq(floor(min(combined_dataset$TEMPERATURE)/5)*5,
                                 ceiling(max(combined_dataset$TEMPERATURE)/5)*5, 
                                 5))),
  aes(x=temp_cut, y=error, group=temp_cut)) +
  geom_boxplot() +
  labs(x = "Temperature range (Celsius)", y = "Forecast error")
```

## Table, mean absolute error in forecast by grouping

```{r}
combined_dataset %>%
  dplyr::summarise(
    mae = mean(abs(error)),
    .by = c(extreme_type, year)
  ) %>%
  tidyr::pivot_wider(names_from = extreme_type, 
                     values_from = mae,
                     names_sort = T) %>%
  dplyr::arrange(year)
```
```{r}
ggplot(combined_dataset, aes(x=year, y=abs(error), 
                             group=extreme_type, fill=extreme_type)) +
  geom_bar(stat="summary", fun="mean", position="dodge")
```

```{r}
ggplot(combined_dataset, aes(x=year, y=error^2, 
                             group=extreme_type, fill=extreme_type)) +
  geom_bar(stat="summary", fun="mean", position="dodge") +
  labs(y = "MSE")
```

# Accuracy of current forecast demand (day)

Aggregate data to a day level

```{r}
combined_dataset_day <- combined_dataset %>%
  dplyr::mutate(date = date(DATETIME),
                month = month(DATETIME)) %>%
  dplyr::summarise(
    # number of observations made for the day
    n_obv = n(),
    # number of intervals with high or low temp recorded
    n_hot = sum(extreme_type=="Hot"),
    n_cold = sum(extreme_type=="Cold"),
    # find the min and max temperatures during the day
    min_temp = min(TEMPERATURE),
    max_temp = max(TEMPERATURE),
    # summarise total and forecast demand during the day
    min_actual = min(TOTALDEMAND),
    max_actual = max(TOTALDEMAND),
    mean_actual = mean(TOTALDEMAND),
    sum_actual = sum(TOTALDEMAND),
    min_forecast = min(FORECASTDEMAND),
    max_forecast = max(FORECASTDEMAND),
    mean_forecast = mean(FORECASTDEMAND),
    sum_forecast = sum(FORECASTDEMAND),
    # basic summary of error across whole day
    mae = mean(abs(error)),
    rmse = sqrt(mean(error^2)),
    max_abs_error = max(abs(error)), 
    # MAE for times under different temp conditions during the day
    mae_hot = mean(abs(error * (extreme_type=="Hot"))),
    mae_normal = mean(abs(error * (extreme_type=="Normal"))),
    mae_cold = mean(abs(error * (extreme_type=="Cold"))),
    # RMSE for times under different temp conditions during the day
    rmse_hot = sqrt(mean(error^2 * (extreme_type=="Hot"))),
    rmse_normal = sqrt(mean(error^2 * (extreme_type=="Normal"))),
    rmse_cold = sqrt(mean(error^2 * (extreme_type=="Cold"))),
    .by = c(year, month, date)
  ) %>%
  dplyr::mutate(
    # set MAE, RMSE by temp conditions to NA if there is no low/high temp
    mae_hot = if_else(n_hot>0, mae_hot, NA),
    mae_cold = if_else(n_cold>0, mae_cold, NA),
    rmse_hot = if_else(n_hot>0, rmse_hot, NA),
    rmse_cold = if_else(n_cold>0, rmse_cold, NA)
  )
```
```{r}
write.csv(combined_dataset_day,
          file = here::here("data/NSW/processed", "nsw_daily.csv"),
          row.names = FALSE)
```

## Chart, max temp vs total demand

```{r}
ggplot(combined_dataset_day, aes(max_temp, sum_actual)) + 
  geom_point() +
  labs(x = "Maximum daily temperature",
       y = "Sum daily total demand")
```
```{r}
ggplot(combined_dataset_day, aes(min_temp, sum_actual)) + 
  geom_point() +
  labs(x = "Minimum daily temperature",
       y = "Sum daily total demand")
```

```{r}
ggplot(combined_dataset_day %>%
         mutate(actual_pr = mean_actual), 
       aes(min_temp, max_temp, col=actual_pr)) + 
  geom_point() +
  scale_color_viridis_c(direction=-1) +
  labs(x = "Minimum daily temperature",
       y = "Maximum daily temperature",
       col = "Mean, Actual Demand")
```

## Chart, error by daily min/max temperatures

```{r}
ggplot(combined_dataset_day %>%
         mutate(mae_pr = percent_rank(mae)), 
       aes(min_temp, max_temp, col=mae_pr, alpha=mae_pr)) + 
  geom_point() +
  scale_color_viridis_c(direction=-1) +
  labs(x = "Minimum daily temperature",
       y = "Maximum daily temperature",
       col = "MAE (ranked)", alpha = "MAE (ranked)")
```

## Chart, scatter of MAE during normal and extreme temperatures

```{r}
ggplot(combined_dataset_day %>% dplyr::filter(n_hot>0), 
       aes(mae_normal, mae_hot, col=max_temp)) +
  geom_point() +
  scale_color_gradient(
    low="orange", high="darkred") +
  coord_fixed(xlim=c(0, 150), ylim=c(0, 150)) +
  labs(x="MAE during normal temp range",
       y="MAE during extreme high temp",
       col="max daily temp")
```

```{r}
ggplot(combined_dataset_day %>% dplyr::filter(n_cold>0), 
       aes(mae_normal, mae_cold, col=min_temp)) +
  geom_point() +
  scale_color_gradient(
    low="darkblue", high="lightblue") +
  coord_fixed(xlim=c(0, 150), ylim=c(0, 150)) +
  labs(x="MAE during normal temp range",
       y="MAE during extreme low temp",
       col="min daily temp")
```

## Chart, boxplot of error by min/max temperature

```{r}
ggplot(
  data = combined_dataset_day %>%
    # group temperatures into lots of 5 for visualisation
    dplyr::mutate(
      temp_cut = cut(
        min_temp, 
        breaks=seq(floor(min(combined_dataset_day$min_temp, na.rm=T)/5)*5,
                   ceiling(max(combined_dataset_day$min_temp, na.rm=T)/5)*5, 
                   5))),
  aes(x=temp_cut, y=mae, group=temp_cut)) +
  geom_boxplot() +
  labs(x = "Daily min temperature (Celsius)", 
       y = "Daily forecast error (MAE)")
```

```{r}
ggplot(
  data = combined_dataset_day %>%
    dplyr::mutate(
      # group temperatures into lots of 5
      temp_cut = cut(
        max_temp, 
        breaks=seq(floor(min(combined_dataset_day$max_temp, na.rm=T)/5)*5,
                   ceiling(max(combined_dataset_day$max_temp, na.rm=T)/5)*5, 
                   5))),
  aes(x=temp_cut, y=mae, group=temp_cut)) +
  geom_boxplot() +
  labs(x = "Daily max temperature (Celsius)", 
       y = "Daily forecast error (MAE)")
```

